{"version":3,"file":"itowns_lasparser.js","mappings":"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","sources":["webpack://itowns/webpack/universalModuleDefinition","webpack://itowns/webpack/runtime/chunk loaded","webpack://itowns/webpack/runtime/startup chunk dependencies","webpack://itowns/./src/Loader/LASLoader.js","webpack://itowns/./src/Worker/LASLoaderWorker.js","webpack://itowns/webpack/bootstrap","webpack://itowns/webpack/runtime/define property getters","webpack://itowns/webpack/runtime/ensure chunk","webpack://itowns/webpack/runtime/get javascript chunk filename","webpack://itowns/webpack/runtime/global","webpack://itowns/webpack/runtime/hasOwnProperty shorthand","webpack://itowns/webpack/runtime/publicPath","webpack://itowns/webpack/runtime/importScripts chunk loading","webpack://itowns/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"itowns_lasparser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"itowns_lasparser\"] = factory();\n\telse\n\t\troot[\"itowns_lasparser\"] = factory();\n})(self, () => {\nreturn ","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(455).then(next);\n};","import { LazPerf } from 'laz-perf';\nimport { Las } from 'copc';\n\n/**\n * @typedef {Object} Header - Partial LAS header.\n * @property {number} header.pointDataRecordFormat - Type of point data\n * records contained by the buffer.\n * @property {number} header.pointDataRecordLength - Size (in bytes) of the\n * point data records. If the specified size is larger than implied by the\n * point data record format (see above) the remaining bytes are user-specfic\n * \"extra bytes\". Those are described by an Extra Bytes VLR.\n * @property {number[]} header.scale - Scale factors (an array `[xScale,\n * yScale, zScale]`) multiplied to the X, Y, Z point record values.\n * @property {number[]} header.offset - Offsets (an array `[xOffset,\n * xOffset, zOffset]`) added to the scaled X, Y, Z point record values.\n */\n\nfunction defaultColorEncoding(header) {\n  return header.majorVersion === 1 && header.minorVersion <= 2 ? 8 : 16;\n}\n\n/**\n * @classdesc\n * Loader for LAS and LAZ (LASZip) point clouds. It uses the copc.js library and\n * the laz-perf decoder under the hood.\n *\n * The laz-perf web assembly module is lazily fetched at runtime when a parsing\n * request is initiated. Location of laz-perf wasm defaults to the unpkg\n * repository.\n */\nclass LASLoader {\n  constructor() {\n    this._wasmPath = 'https://cdn.jsdelivr.net/npm/laz-perf@0.0.6/lib';\n    this._wasmPromise = null;\n  }\n  _initDecoder() {\n    if (this._wasmPromise) {\n      return this._wasmPromise;\n    }\n    this._wasmPromise = LazPerf.create({\n      locateFile: file => `${this._wasmPath}/${file}`\n    });\n    return this._wasmPromise;\n  }\n  _parseView(view, options) {\n    const colorDepth = options.colorDepth ?? 16;\n    const getPosition = ['X', 'Y', 'Z'].map(view.getter);\n    const getIntensity = view.getter('Intensity');\n    const getReturnNumber = view.getter('ReturnNumber');\n    const getNumberOfReturns = view.getter('NumberOfReturns');\n    const getClassification = view.getter('Classification');\n    const getPointSourceID = view.getter('PointSourceId');\n    const getColor = view.dimensions.Red ? ['Red', 'Green', 'Blue'].map(view.getter) : undefined;\n    const getScanAngle = view.getter('ScanAngle');\n    const positions = new Float32Array(view.pointCount * 3);\n    const intensities = new Uint16Array(view.pointCount);\n    const returnNumbers = new Uint8Array(view.pointCount);\n    const numberOfReturns = new Uint8Array(view.pointCount);\n    const classifications = new Uint8Array(view.pointCount);\n    const pointSourceIDs = new Uint16Array(view.pointCount);\n    const colors = getColor ? new Uint8Array(view.pointCount * 4) : undefined;\n    /*\n    As described by the LAS spec, Scan Angle is encoded:\n    - as signed char in a valid range from -90 to +90 (degrees) prior to the LAS 1.4 Point Data Record Formats (PDRF) 6\n    - as a signed short in a valid range from -30 000 to +30 000. Those values represents scan angles from -180 to +180\n      degrees with an increment of 0.006 for PDRF >= 6.\n    The copc.js library does the degree convertion and stores it as a `Float32`.\n    */\n    const scanAngles = new Float32Array(view.pointCount);\n\n    // For precision we take the first point that will be use as origin for a local referentiel.\n    const origin = getPosition.map(f => f(0)).map(val => Math.floor(val));\n    for (let i = 0; i < view.pointCount; i++) {\n      // `getPosition` apply scale and offset transform to the X, Y, Z\n      // values. See https://github.com/connormanning/copc.js/blob/master/src/las/extractor.ts.\n      const [x, y, z] = getPosition.map(f => f(i));\n      positions[i * 3] = x - origin[0];\n      positions[i * 3 + 1] = y - origin[1];\n      positions[i * 3 + 2] = z - origin[2];\n      intensities[i] = getIntensity(i);\n      returnNumbers[i] = getReturnNumber(i);\n      numberOfReturns[i] = getNumberOfReturns(i);\n      if (getColor) {\n        // Note that we do not infer color depth as it is expensive\n        // (i.e. traverse the whole view to check if there exists a red,\n        // green or blue value > 255).\n        let [r, g, b] = getColor.map(f => f(i));\n        if (colorDepth === 16) {\n          r /= 256;\n          g /= 256;\n          b /= 256;\n        }\n        colors[i * 4] = r;\n        colors[i * 4 + 1] = g;\n        colors[i * 4 + 2] = b;\n        colors[i * 4 + 3] = 255;\n      }\n      classifications[i] = getClassification(i);\n      pointSourceIDs[i] = getPointSourceID(i);\n      scanAngles[i] = getScanAngle(i);\n    }\n    return {\n      position: positions,\n      intensity: intensities,\n      returnNumber: returnNumbers,\n      numberOfReturns,\n      classification: classifications,\n      pointSourceID: pointSourceIDs,\n      color: colors,\n      scanAngle: scanAngles,\n      origin\n    };\n  }\n\n  /**\n   * Set LazPerf decoder path.\n   * @param {string} path - path to `laz-perf.wasm` folder.\n   */\n  set lazPerf(path) {\n    this._wasmPath = path;\n    this._wasmPromise = null;\n  }\n\n  /**\n   * Parses a LAS or LAZ (LASZip) chunk. Note that this function is\n   * **CPU-bound** and shall be parallelised in a dedicated worker.\n   * @param {Uint8Array} data - File chunk data.\n   * @param {Object} options - Parsing options.\n   * @param {Header} options.header - Partial LAS header.\n   * @param {number} options.pointCount - Number of points encoded in this\n   * data chunk.\n   * @param {Las.ExtraBytes[]} [options.eb] - Extra bytes LAS VLRs\n   * headers.\n   * @param {8 | 16} [options.colorDepth] - Color depth encoding (in bits).\n   * Either 8 or 16 bits. Defaults to 8 bits for LAS 1.2 and 16 bits for later\n   * versions (as mandatory by the specification).\n   */\n  async parseChunk(data, options) {\n    const {\n      header,\n      eb,\n      pointCount\n    } = options;\n    const {\n      pointDataRecordFormat,\n      pointDataRecordLength\n    } = header;\n    const colorDepth = options.colorDepth ?? defaultColorEncoding(header);\n    const bytes = new Uint8Array(data);\n    const pointData = await Las.PointData.decompressChunk(bytes, {\n      pointCount,\n      pointDataRecordFormat,\n      pointDataRecordLength\n    }, this._initDecoder());\n    const view = Las.View.create(pointData, header, eb);\n    const attributes = this._parseView(view, {\n      colorDepth\n    });\n    return {\n      attributes\n    };\n  }\n\n  /**\n   * Parses a LAS or LAZ (LASZip) file. Note that this function is\n   * **CPU-bound** and shall be parallelised in a dedicated worker.\n   * @param {ArrayBuffer} data - Binary data to parse.\n   * @param {Object} [options] - Parsing options.\n   * @param {8 | 16} [options.colorDepth] - Color depth encoding (in bits).\n   * Either 8 or 16 bits. Defaults to 8 bits for LAS 1.2 and 16 bits for later\n   * versions (as mandatory by the specification)\n   */\n  async parseFile(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const bytes = new Uint8Array(data);\n    const pointData = await Las.PointData.decompressFile(bytes, this._initDecoder());\n    const header = Las.Header.parse(bytes);\n    const colorDepth = options.colorDepth ?? defaultColorEncoding(header);\n    const getter = async (begin, end) => bytes.slice(begin, end);\n    const vlrs = await Las.Vlr.walk(getter, header);\n    const ebVlr = Las.Vlr.find(vlrs, 'LASF_Spec', 4);\n    const eb = ebVlr && Las.ExtraBytes.parse(await Las.Vlr.fetch(getter, ebVlr));\n    const view = Las.View.create(pointData, header, eb);\n    const attributes = this._parseView(view, {\n      colorDepth\n    });\n    return {\n      header,\n      attributes\n    };\n  }\n}\nexport default LASLoader;","import { expose, Transfer } from 'threads/worker';\nimport LASLoader from \"../Loader/LASLoader.js\";\nconst loader = new LASLoader();\nfunction transferable(attributes) {\n  return Object.values(attributes).filter(ArrayBuffer.isView).map(a => a.buffer);\n}\nexpose({\n  lazPerf(path) {\n    loader.lazPerf = path;\n  },\n  async parseChunk(data, options) {\n    const result = await loader.parseChunk(data, options);\n    return Transfer(result, transferable(result.attributes));\n  },\n  async parseFile(data, options) {\n    const result = await loader.parseFile(data, options);\n    return Transfer(result, transferable(result.attributes));\n  }\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [455], () => (__webpack_require__(57699)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t899: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkitowns\"] = self[\"webpackChunkitowns\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["root","factory","exports","module","define","amd","self","deferred","next","defaultColorEncoding","header","majorVersion","minorVersion","loader","constructor","this","_wasmPath","_wasmPromise","_initDecoder","LazPerf","create","locateFile","file","_parseView","view","options","colorDepth","getPosition","map","getter","getIntensity","getReturnNumber","getNumberOfReturns","getClassification","getPointSourceID","getColor","dimensions","Red","undefined","getScanAngle","positions","Float32Array","pointCount","intensities","Uint16Array","returnNumbers","Uint8Array","numberOfReturns","classifications","pointSourceIDs","colors","scanAngles","origin","f","val","Math","floor","i","x","y","z","r","g","b","position","intensity","returnNumber","classification","pointSourceID","color","scanAngle","lazPerf","path","parseChunk","data","eb","pointDataRecordFormat","pointDataRecordLength","bytes","pointData","Las","PointData","decompressChunk","View","attributes","parseFile","arguments","length","decompressFile","Header","parse","async","begin","end","slice","vlrs","Vlr","walk","ebVlr","find","ExtraBytes","fetch","transferable","Object","values","filter","ArrayBuffer","isView","a","buffer","result","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","m","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","keys","every","key","splice","d","definition","o","defineProperty","enumerable","get","e","chunkId","Promise","all","reduce","promises","u","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","scriptUrl","importScripts","location","document","currentScript","tagName","toUpperCase","src","scripts","getElementsByTagName","test","Error","replace","p","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","push","bind","moreModules","runtime","pop","then"],"sourceRoot":""}